# Weak Encryption

## Analysis

The guide provided a Python script which detailed the cipher used to encrypt the key. The script, named "cipherspec.py", contained three distinct functions:

* **gen() -** This function is used to generate the cipher key.

```python
def gen(): 
	offset = 3 # Hotfix to make Crypto blazing fast!!
	key = bytearray(b'\x00'*(KEYLEN-offset)) 
	key.extend(os.urandom(offset))
	return bytes(key)
```

* **enc() -** A function which, given a <u>key</u>, a <u>message</u> and a <u>nonce</u>, encrypts the message using the AES cipher.
* **dec() -** A function which, given a <u>key</u>, a <u>ciphertext</u> and a <u>nonce</u>, decrypts the ciphertext according to the AES cipher.

We opted to not include the source code for the last two functions, seeing as they do not possess any vulnerabilities. In fact, the problem lies in the key generation function.

The issue is very simple: only the last three bytes of the **key** are being randomized. This is because the variable "offset", defined in the first line of the key generation function, is being used to establish how many bytes of the key should be random as seen below:

```python
key = bytearray(b'\x00'*(KEYLEN-offset)) # create a byte array with 0's
key.extend(os.urandom(offset)) # append to that array a few random bytes
```

Seeing as the value of "offset" is **3**, the key was being generated by creating an array of bytes with the value 0 and appending to that array a mere three random bytes. Since three is a very low number, this cipher was vulnerable to **brute-force** attacks, that is, we could try out every possible key to discover which one was used to encrypt the message.

To that end, we would need to create a byte array filled with 0s, which would be our key. Then, we would attempt to decrypt the message using said key. If the decrypted message was the **flag**, we could stop, otherwise we would increment the last three bytes and try again.

## Preparing the Script

Before writing our code, we needed a few variables: the **ciphertext** and the **nonce**. By connecting to the server, we obtained them as follows:



Next, we started writing our script. Its behaviour can be summarized like so:

* Iterate through all the possible keys. Since only the last three bytes could be different from 0, the keys were all the numbers belonging to [0, 2^24[.

```python
for key in range(2**24):
    ...
```

* Decrypt the ciphertext using said keys.

```python
msg = dec(ciphertext, key, nonce)
```

* Verify if the decrypted message is the flag using a **regular expression**.

```python
if (re.search("flag{[0-9][a-z]}")):
    print msg # flag found!
    break
```

With the added ciphertext and nonce values, the finalized script was the following:

```python
import re # regex
import cipherspec.py

ciphertext = 0x5ec0245e54dc7f4cbbc4941577d4f7ddab198caab78702646c1d853c6912a7d7f4052ba72c3ae6
nonce = 0xaab55d811f9e312a7cf589de98157163

for key in range(255 ** 3):
	msg = dec(ciphertext, key, nonce)
	
	if (re.search("flag{[0-9][a-z]}")):
		print msg # flag found!
		break
```

